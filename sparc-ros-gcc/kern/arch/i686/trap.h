#ifndef ROS_INCLUDE_ARCH_TRAP_H
#define ROS_INCLUDE_ARCH_TRAP_H

#define MSR_IA32_SYSENTER_CS 0x174
#define MSR_IA32_SYSENTER_ESP 0x175
#define MSR_IA32_SYSENTER_EIP 0x176

// Trap numbers
// These are processor defined:
#define T_DIVIDE     0		// divide error
#define T_DEBUG      1		// debug exception
#define T_NMI        2		// non-maskable interrupt
#define T_BRKPT      3		// breakpoint
#define T_OFLOW      4		// overflow
#define T_BOUND      5		// bounds check
#define T_ILLOP      6		// illegal opcode
#define T_DEVICE     7		// device not available 
#define T_DBLFLT     8		// double fault
/* #define T_COPROC  9 */	// reserved (not generated by recent processors)
#define T_TSS       10		// invalid task switch segment
#define T_SEGNP     11		// segment not present
#define T_STACK     12		// stack exception
#define T_GPFLT     13		// genernal protection fault
#define T_PGFLT     14		// page fault
/* #define T_RES    15 */	// reserved
#define T_FPERR     16		// floating point error
#define T_ALIGN     17		// aligment check
#define T_MCHK      18		// machine check
#define T_SIMDERR   19		// SIMD floating point error

// These are arbitrarily chosen, but with care not to overlap
// processor defined exceptions or interrupt vectors.

// T_SYSCALL is defined by the following include:
#include <ros/arch/syscall.h>

#define T_DEFAULT   0xdeadbeef		// catchall

/* IPIs */
/* Testing IPI (used in testing.c) */
#define I_TESTING		230
/* smp_call_function IPIs, keep in sync with NUM_HANDLER_WRAPPERS (and < 16)
 * it's important that this begins with 0xf0.  check i386/trap.c for details. */
#define I_SMP_CALL0 	0xf0 // 240
#define I_SMP_CALL1 	0xf1
#define I_SMP_CALL2 	0xf2
#define I_SMP_CALL3 	0xf3
#define I_SMP_CALL4 	0xf4
#define I_SMP_CALL_LAST I_SMP_CALL4
/* Direct/Hardwired IPIs.  Hardwired in trapentry.S */
#define I_ACTIVE_MSG	255

/* Number of active messages available per core (arbitrary) */
#define NUM_ACTIVE_MESSAGES 5


#ifndef __ASSEMBLER__

#include <ros/common.h>
#include <arch/mmu.h>

/* The kernel's interrupt descriptor table */
extern gatedesc_t idt[];
extern taskstate_t ts;

typedef struct PushRegs {
	/* registers as pushed by pusha */
	uint32_t reg_edi;
	uint32_t reg_esi;
	uint32_t reg_ebp;
	uint32_t reg_oesp;		/* Useless */
	uint32_t reg_ebx;
	uint32_t reg_edx;
	uint32_t reg_ecx;
	uint32_t reg_eax;
} push_regs_t;

typedef struct Trapframe {
	push_regs_t tf_regs;
	uint16_t tf_gs;
	uint16_t tf_padding1;
	uint16_t tf_fs;
	uint16_t tf_padding2;
	uint16_t tf_es;
	uint16_t tf_padding3;
	uint16_t tf_ds;
	uint16_t tf_padding4;
	uint32_t tf_trapno;
	/* below here defined by x86 hardware */
	uint32_t tf_err;
	uintptr_t tf_eip;
	uint16_t tf_cs;
	uint16_t tf_padding5;
	uint32_t tf_eflags;
	/* below here only when crossing rings, such as from user to kernel */
	uintptr_t tf_esp;
	uint16_t tf_ss;
	uint16_t tf_padding6;
} trapframe_t;

typedef struct AncillaryState {
	uint32_t silly; // remove this when you actually use this struct
} ancillary_state_t;

static inline void set_errno(trapframe_t* tf, uint32_t errno)
{
	tf->tf_regs.reg_esi = errno;
}

#endif /* !__ASSEMBLER__ */

#endif /* !ROS_INC_ARCH_TRAP_H */
